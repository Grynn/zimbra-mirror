#!/usr/bin/perl
#
# ***** BEGIN LICENSE BLOCK *****
#
# Zimbra Collaboration Suite Server
# Copyright (C) 2005 Zimbra, Inc.
#
# The contents of this file are subject to the Yahoo! Public License
# Version 1.0 ("License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://www.zimbra.com/license.
#
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
#
# ***** END LICENSE BLOCK *****
#

#$SIG{'__WARN__'} = sub { die "$_[0]" };

use lib qw(/opt/zimbra/zimbramon/lib);
use warnings;
use strict;
use Text::Balanced qw(extract_delimited extract_bracketed);
use Data::Dumper;
use sigtrap qw(QUIT);
use XML::Parser;
use Getopt::Std;


my $attendeeLimit = 50;
my %opts = ();
getopts('dm:', \%opts);
sub usage() {
    print STDERR <<"EOF";
Usage: zmcalchk [-d] <user> <start-time-spec> <end-time-spec>

    See the output of 'zmmailbox help appointment' for details on time-specs.

    -d        DEBUG: extremely verbose details
    -m        Max attendees to check, (default $attendeeLimit)

EOF
    exit;
}
if (@ARGV < 3) {
    usage();
}

my $debug = $opts{'d'};
if (exists $opts{'m'}) {
    $attendeeLimit = $opts{'m'};
    usage() if ($attendeeLimit !~ /^\d+$/);
    print STDERR "Setting max attendee check limit to $attendeeLimit\n" if ($debug);
}

my $source_user = shift @ARGV;
my $ts_start    = shift @ARGV;
my $ts_end      = shift @ARGV;

my $zmlocalconfig = '/opt/zimbra/bin/zmlocalconfig';

my %userHostMap = ();
my %userFolderList = ();
my %userEventCache = ();
my %distributionLists = ();

my $adminPort;
my @domains;

my $host;

sub getDomains() {
    my @domains = ();
    my @response = ZmClient::sendZmprovRequest("gad");
    for (@response) {
        chomp();
        push(@domains, $_);
    }
    @domains;
}
sub getAdminServicePort() {
    open(ZMLOCALCONFIG, "$zmlocalconfig zimbra_admin_service_port |") || die $!;
    my $line = <ZMLOCALCONFIG>;
    chomp($line);
    close(ZMLOCALCONFIG);
    (split(/\s+=\s+/, $line))[1];
}

# trivial (crappy) json parser, avoids having to depend on the JSON module,
# an additional download

sub process_simple_json_object($) {
    my $section = shift;
    my %object = ();


    $section =~ s/^\s*^\{(.*?)\}\s*$/$1/os;
    while ($section !~ /^\s*$/o) {
        my $entry = extract_delimited($section, qq/"/, qr/\s*,?\s*/);
        if (!defined($entry) || $entry eq '') {
            $section =~ s/\s*,?\s*(\S+)://o;
            $entry = $1;
        }
        my $value = undef;
        if ($section =~ m#^\s*:?\s*(?=(\[|{))#o) {
            my $type = $1;
            if ($type eq '{') {
                my $subsection = extract_bracketed($section, '{"}', qr/\s*:?\s*/);
                if (!defined($subsection) || $subsection eq '') {
                    print STDERR "SECTION: $section\n" if ($debug);
                    die "unable to extract object text from JSON";
                }
                $value = &process_simple_json_object($subsection);
            } elsif ($type eq '[') {
                my $subsection = extract_bracketed($section, '["]', qr/\s*:?\s*/);
                if (!defined($subsection) || $subsection eq '') {
                    print STDERR "SECTION: $section\n" if ($debug);
                    die "unable to extract list text from JSON";
                }
                $value = process_simple_json_list($subsection);
            }
        } else {
            $value = extract_delimited($section, qq/"/, qr/\s*:?\s*/);
            if (!defined($value) || $value eq '') {
                $section =~ s#\s*:?\s*(\S+\s*(/\*.*\*/)?)\s*,?\s*##o;
                $value = $1;
                $value =~ s/\s*$//;
                $value =~ s/,//;
            }
        }
        $entry =~ s/^"(.*)"$/$1/;
        $value =~ s/^"(.*)"$/$1/;
        $object{$entry} = $value;
        my $p = pos($section);
        $p = defined($p) ? $p : 0;
        my $l = length($section);
        last if ($l - $p < 3); # can't possibly have an entry in 3 chars can we
    }
    \%object;
}

sub process_simple_json_list($) {
    my $json = shift;
    my @list = ();
    while (my $block = extract_bracketed($json, '{"}', qr/\s*,?\[?\s*/)) {
        my $object = process_simple_json_object($block);
        push(@list, $object);
    }
    \@list;
}
sub process_simple_json($) {
    my $json = shift;
    die "JSON result did not start with { or [: $json"
            if ($json !~ /^\s*(?=([\[{]))/go);
    my $type = $1;

    if ($type eq '{') {
        return process_simple_json_object($json);
    } elsif ($type eq '[') {
        return process_simple_json_list($json);
    } else {
        die "Unknown JSON starting character: $type\n";
    }
}
### end basic JSON parser

sub getMailServer($) {
    my $user = shift;
    my $mailhost;

    return $userHostMap{$user} if (exists($userHostMap{$user}));

    print STDERR "LOOKUP USER: ga $user\n" if ($debug);
    my @response = ZmClient::sendZmprovRequest("ga $user");
    for (@response) {
        if ($_ =~ /^zimbraAccountStatus:\s*(\S+)/) {
            if ($1 ne 'active') {
                undef($mailhost);
                last;
            }
        }
        if ($_ =~ /^zimbraMailHost:\s*(\S+)/) {
            $mailhost = $1;
        }
        last if ($_ =~ /ERROR: account.NO_SUCH_ACCOUNT/);
    }
    die "$user does not exist" if (!defined($mailhost));
    $userHostMap{$user} = $mailhost;
    ZmClient::initZmmailbox($mailhost, $adminPort);
    $mailhost;
}

sub getCalendarFolders($$) {
    my $host = shift;
    my $login = shift;
    my @appo_folders = ();
    print STDERR "LIST FOLDERS: sm $login; gaf\n" if ($debug);
    ZmClient::sendZmmailboxRequest($host, "sm $login");
    my $response = ZmClient::sendZmmailboxRequestNP($host, "gaf");
    for (split(/\n/, $response)) {
        if (m{\s*\d+\s+appo\s+\d+\s+\d+\s+(/.*?)$}) {
            my $folder = $1;
            # ignore shared folders \(\S+\)$
            push(@appo_folders, $folder) if ($folder !~ m{\(\s*\S+\s*\)$})
        }
    }
    @appo_folders;
}

my %userCalendarCached = ();
# throws a die from getMailServer
sub findCalendarItem($$) {
    my ($login, $item) = @_;


    if (!exists($userFolderList{$login})) {
        $userFolderList{$login} = [
                getCalendarFolders(getMailServer($login), $login) ];
        $userEventCache{$login} = {};
        $userCalendarCached{$login} = {};
    }
    # avoid unnecessary searches
    if (exists($userEventCache{$login}->{$item->{'uid'}}) ) {
        print STDERR "found cached: $login => $$item{'uid'}\n" if ($debug);

        return $userEventCache{$login}->{$item->{'uid'}};
    }


    my $calendarItem;

    print STDERR "SEARCHING FOLDERS: sm $login\n" if ($debug);
    ZmClient::sendZmmailboxRequest($host, "sm $login");
    my @folderList = @{$userFolderList{$login}};
    FOLDER: foreach my $folder (@folderList) {
        # cached, skip it
        if (exists($userCalendarCached{$login}->{$folder})) {
            print STDERR "$login: [$folder] already cached, skipping\n" if ($debug);
            next;
        }
        $folder =~ s/"/\\"/g;
        $folder =~ s/\$/\\\$/g;
        print STDERR "SEARCHING FOLDER: gaps $ts_start $ts_end \"$folder\"\n" if ($debug);
        my $json_string = ZmClient::sendZmmailboxRequest($host, "gaps $ts_start $ts_end \"$folder\"");
        my $jsonObj = process_simple_json($json_string);
        if (exists($jsonObj->{'Body'}->{'SearchResponse'}->{'appt'})) {
            foreach my $appt (@{$jsonObj->{'Body'}->{'SearchResponse'}->{'appt'}}) {
                $calendarItem = $appt if ($appt->{'uid'} eq $item->{'uid'});

                # cache the found event--may be useful later
                $userEventCache{$login}->{$appt->{'uid'}} = $appt;
            }
            last FOLDER if (defined($calendarItem));
        }
        $userCalendarCached{$login}->{$folder} = 1;
    }

    $calendarItem;
}

sub getCalendarSummary($$$) {
    my $host = shift;
    my $login = shift;
    my $folder = shift;
    $folder =~ s/"/\\"/g;
    $folder =~ s/!/\\!/g;
    $folder =~ s/[\$]/\\\$/g;
    ZmClient::sendZmmailboxRequest($host, "sm $login");
    print "gaps $ts_start $ts_end \"$folder\"\n" if ($debug);
    my $json_string = ZmClient::sendZmmailboxRequest($host, "gaps $ts_start $ts_end \"$folder\"");
    process_simple_json($json_string);
}

sub getInstanceByInstId($$) {
    my ($item, $id) = @_;
    my $instance;

    if (exists($item->{'inst'})) {
        my $instList = $item->{'inst'};
        foreach my $inst (@{$instList}) {
            if ($inst->{'ridZ'} eq $id) {
                $instance = $inst;
                last;
            }
        }
    }
    $instance;
}
sub getInstanceByStartTime($$) {
    my ($item, $time) = @_;
    my $instance;

    if (exists($item->{'inst'})) {
        my $instList = $item->{'inst'};
        foreach my $inst (@{$instList}) {
            if ($inst->{'s'} eq $time) {
                $instance = $inst;
                last;
            }
        }
    }
    $instance;
}

sub expandAttendees($) {
    my ($item) = @_;

    my %seen = ();
    my $expanded = 0;
    do {
        $expanded = 0;

        my @attList = keys %{$item->{'attendeesList'}};
        die "over attendee limit of $attendeeLimit\n" if (@attList > $attendeeLimit);
        foreach my $att (@attList) {
            # skip if already processed; prevent infinite looping
            next if (exists($seen{$att}));
            eval {
                if (!exists($userHostMap{$att}) && !exists($distributionLists{$att})) {
                    getMailServer($att);
                }
            };
            if ($@) {
                # non-existent users are treated as an empty distribution list
                $distributionLists{$att} = [];
                print STDERR "Expanding distribution list: $att ($@)\n" if ($debug);
                my @response = ZmClient::sendZmprovRequest("gdl $att");
                for (@response) {
                    last if ($_ =~ /ERROR: account.NO_SUCH_DISTRIBUTION_LIST/);
                    next if ($_ !~ /^zimbraMailForwardingAddress:\s+(\S+)/);
                    push(@{$distributionLists{$att}}, $1);
                }
            }
            if (exists($distributionLists{$att})) {
                delete $item->{'attendeesList'}->{$att};
                print STDERR "Adding distribution list attendees: $att\n" if ($debug);
                foreach my $expAtt (@{$distributionLists{$att}}) {
                    if (!exists($item->{'attendeesList'}->{$expAtt})) {
                        $item->{'attendeesList'}->{$expAtt} = {
                            rsvp => 'unknown', role => 'unknown',
                        };
                    }
                }
                $expanded = 1;
            }
            $seen{$att} = 1;
        }
    } while ($expanded);
}

sub getItem($$) {
    my ($user, $item) = @_;

    print STDERR "Retrieving item $$item{'id'} ($user)\n" if $debug;
    print STDERR "getItemRequest($user, $$item{'id'})\n" if ($debug);

    my $ms = getMailServer($user);
    my $calendarItem = ZmClient::getItemRequest($ms, $user, $item->{'id'});
    $CalendarItemParser::itemRef = $item;
    my $p = new XML::Parser(Style => 'Subs', Pkg => 'CalendarItemParser');
    $p->parse($calendarItem);
}

sub main() {

    ZmClient::init();
    ZmClient::initZmprov();

    @domains = getDomains();
    $adminPort = getAdminServicePort();
    $host = getMailServer($source_user);
    my @folders = getCalendarFolders($host, $source_user);
    my @calendar_items = ();
    print "Calendars: " . join(", ", @folders) . "\n";
    for (@folders) {
        print "Retrieving calendar: $_\n";
        my $results = getCalendarSummary($host, $source_user, $_);
        if (exists($results->{'Body'}->{'SearchResponse'}->{'appt'})) {
            push(@calendar_items,
                    @{$results->{'Body'}->{'SearchResponse'}->{'appt'}});
        }
    }
    my @items = ();
    print "Total calendar items: " . scalar(@calendar_items) . "\n";
    print "Pruning non-local attendees and items without attendees\n";
    foreach my $item (@calendar_items) {
        my $has_atts = $item->{"otherAtt"};
        next if (!defined($has_atts) || $has_atts eq '' || $has_atts eq 'false');

        getItem($source_user, $item);

        next if (scalar keys(%{$item->{'attendeesList'}}) == 0);
        my $or = $item->{'or'}->{'a'};
        $or =~ s/\@\S+$//;
        my $src = $source_user;
        $src =~ s/\@\S+$//;
        my $found = 0;
        if ($or ne $src) {
            foreach my $domain (@domains) {
                $found = $item->{'or'}->{'a'} =~ /\@$domain$/i if (!$found);
            }
            if (!$found) {
                $or = $item->{'or'}->{'a'};
                next;
            }
        }

        push(@items, $item);
    }

    print "Remaining items to check: " . scalar(@items) . "\n";
    print STDERR Dumper(\@items) if ($debug);
    my $i = 0;
    my $itemCount = @items;
    foreach my $item (@items) {
        $i++;
        my @errors = ();
        my $or = $item->{'or'}->{'a'};
        $or =~ s/\@\S+$//;
        my $src = $source_user;
        $src =~ s/\@\S+$//;

        # save itemId in case it's another organizer
        my $itemId = $item->{'id'};

        print "Checking event $itemId [$$item{'name'}] $i/$itemCount\n";

        if ($or ne $src) {
            my $or_item;
            eval {
                $or_item = findCalendarItem($or, $item);
                if (defined($or_item)) {
                    getItem($or, $or_item);
                }
            };
            if ($@) {
                push(@errors, "$or: organizer account not found: $@");
            }
            if (!defined($or_item)) {
                push(@errors, "$or: organizer's event not found!");
            } else {
                $item = $or_item;
            }
        }

        eval {
            expandAttendees($item);
        };
        if ($@) {
            my $m = $@;
            chomp($m);
            print "$$item{'name'}: $m; skipping check\n\n";
            next;
        }
        my @attList = keys %{$item->{'attendeesList'}};

        print STDERR "Attendees: [" . join(", ", @attList) . "]\n" if ($debug);
        foreach my $att (@attList) {
            my $attItem;
            eval {
                $attItem = findCalendarItem($att, $item);
            };
            if ($@) {
                push(@errors, "$att: unable to find calendar event: $@");
            }
            if (!defined($attItem)) {
                my $h = $item->{'attendeesList'}->{$att};
                my $rsvp = defined($$h{'rsvp'}) ? $$h{'rsvp'} : 'undefined';
                my $role = defined($$h{'role'}) ? $$h{'role'} : 'undefined';
                push(@errors, "$att: no matching event found; rsvp=$rsvp, role=$role");
            } else {
                foreach my $instance (@{$item->{'inst'}}) {
                    if (!defined($instance->{'ridZ'})) {
                        print STDERR "WARNING: recurrence ID not found for $$item{'name'}\n" if ($debug);
                        next;
                    }

                    my $attInst;
                    if (exists $instance->{'ridZ'}
                            && defined $instance->{'ridZ'}) {
                        $attInst = getInstanceByInstId($attItem, $instance->{'ridZ'});
                    } else {
                        $attInst = getInstanceByStartTime($attItem, $instance->{'s'});
                        $instance->{'ridZ'} = "N/A";
                    }
                    my $iTime = scalar localtime($instance->{'s'} / 1000);
                    if (!defined($attInst)) {
                        push(@errors, "$att:$$attItem{'id'} no instance found for ridZ=$$instance{'ridZ'}, time=$iTime");
                    }
                    elsif ($attInst->{'s'} != $instance->{'s'}) {
                        my $aTime = scalar localtime($attInst->{'s'} / 1000);
                        push(@errors, "$att:$$attItem{'id'} time mismatch: $iTime != $aTime");
                    }
                }
            }
        }
        my $desc = " * $$item{'name'}: id=$itemId, uid=$$item{'uid'}, organizer=$or";
        my @times = ();
        foreach my $inst (@{$item->{'inst'}}) {
            push(@times, scalar localtime($inst->{'s'} / 1000));
        }

        $desc .= ", times=[" . join(', ', @times) . "]";
        $desc .= ", attendees=[" . join(', ', @attList) . "]";
        if (@errors > 0) {
            print "\@\@\@:$$item{'id'} $desc\n";
            for (@errors) {
                print "\@\@\@:$$item{'id'}    $_\n";
            }
            if ($debug) {
                print STDERR Dumper($item);
            }
            print "\n";
        } else {
            if ($debug) {
                print STDERR $desc . "\n";
                print STDERR "        NO INCONSISTENCIES FOUND\n\n";
            }
        }
    }
}


main();

package CalendarItemParser;


our $itemRef;

sub at {
    my ($expat, $elem, %attrs) = @_;
    $itemRef->{'attendeesList'} = {} if (!exists($itemRef->{'attendeesList'}));
    my $found = 0;
    foreach my $domain (@domains) {
        $found = $attrs{'a'} =~ /\@$domain$/i if (!$found);
    }
    if ($found) {
        $itemRef->{'attendeesList'}->{$attrs{'a'}} = {
            rsvp => $attrs{'rsvp'}, role => $attrs{'role'},
        }
    }
}

package ZmClient;

use IPC::Open2;
use IO::Handle;
use Net::HTTP;
use LWP::UserAgent;
use HTTP::Request;

my $zmprov_exe = '/opt/zimbra/bin/zmprov';
my %zmprov = ();
my $zmmailbox_exe = '/opt/zimbra/bin/zmmailbox';
my %zmmailbox = ();
my %authTokens = ();

sub init() {
    $zmprov_exe = '/opt/zimbra/bin/zmprov';
    %zmprov = ();
    $zmmailbox_exe = '/opt/zimbra/bin/zmmailbox';
    %zmmailbox = ();
    %authTokens = ();
}

sub initZmprov() {
    my $buf;
    return if (exists $zmprov{'pid'} && kill(0, $zmprov{'pid'}));
    $zmprov{'pid'} = open2(
            $zmprov{'in'}, $zmprov{'out'}, "$zmprov_exe 2>&1 ") || die "$!";
    do { # this part, we can ignore
        sysread($zmprov{'in'}, $buf, 8192);
    } while ($buf !~ /^prov> $/osm);
}

sub sendZmprovRequest($) {
    my $cmd = shift @_;
    my $buf;
    die "zmprov not initialized" if (!exists $zmprov{'out'});
    $zmprov{'out'}->print($cmd . "\n");
    my @lines = ();
    my $needs_join = 0;

    do {
        sysread($zmprov{'in'}, $buf, 8192);
        my @newlines = split(/\n/, $buf);

        if ($needs_join) {
            $lines[$#lines] .= shift @newlines if @newlines > 0;
            $needs_join = 0;
        }

        $needs_join = 1 if ($buf !~ /\n$/osm);

        push(@lines, @newlines);
    } while ($buf !~ /^prov> $/osm);
    pop @lines if ($lines[$#lines] =~ /^prov> $/osm);
    wantarray ? @lines : join("\n", @lines);
}

sub getItemRequest($$$) {
    my ($host, $login, $itemId) = @_;
    my $authToken = getDelegateAuthToken($host, $login);
    my $port = $zmmailbox{$host}->{'port'};
    my $url = "https://$host:$port/service/admin/soap/";

    my $item_request = <<"EOF";
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://www.w3.org/2003/05/soap-envelope">
  <soap:Body>
    <GetItemRequest xmlns="urn:zimbraMail">
      <item id="$itemId"/>
    </GetItemRequest>
  </soap:Body>
  <soap:Header>
    <context xmlns="urn:zimbra">
      <authToken>$authToken</authToken>
    </context>
  </soap:Header>
</soap:Envelope>
EOF
    my $ua = LWP::UserAgent->new;
    $ua->agent("ZmCalChk/0.1");

    my $req = HTTP::Request->new(POST => $url);
    $req->content_type("application/xml");
    $req->content($item_request);
    my $resp = $ua->request($req);

    if ($resp->is_success) {
        return $resp->content;
    } else {
        print $resp->content if ($debug);
        die $resp->status_line;
    }
}

sub initZmmailbox($$) {
    my ($host, $port) = @_;
    return if (exists $zmmailbox{$host}->{'pid'} &&
               kill(0, $zmmailbox{$host}->{'pid'}));

    my $buf;
    $zmmailbox{$host} = {};
    $zmmailbox{$host}->{'pid'} = open2(
            $zmmailbox{$host}->{'in'}, $zmmailbox{$host}->{'out'},
            "$zmmailbox_exe -u https://$host:$port/ -d -z 2>&1 ") || die "$!";
    do { # this part, we can ignore
        sysread($zmmailbox{$host}->{'in'}, $buf, 8192);
    } while ($buf !~ /^mbox> $/osm);
    $zmmailbox{$host}->{'port'} = $port;
}

sub getDelegateAuthToken($$) {
    my ($host, $login) = @_;

    return $authTokens{$login} if (exists $authTokens{$login});

    my $authToken = {};
    &sendZmmailboxRequest($host, "sm $login", $authToken);
    $authTokens{$login} = $authToken->{'value'};
}

# NP = no parsing
sub sendZmmailboxRequestNP($$) {
    my ($host, $cmd) = @_;
    my $buf;
    die "zmmailbox for $host not initialized" if (!exists $zmmailbox{$host});
    $zmmailbox{$host}->{'out'}->print($cmd . "\n");
    my @lines = ();
    my $needs_join = 0;

    do {
        sysread($zmmailbox{$host}->{'in'}, $buf, 8192);
        my @newlines = split(/\n/, $buf);

        if ($needs_join) {
            $lines[$#lines] .= shift @newlines;
            $needs_join = 0;
        }

        $needs_join = 1 if ($buf !~ /\n$/osm);

        push(@lines, @newlines);
    } while ($buf !~ /^mbox\s*\S*?> $/osm);
    pop @lines if ($lines[$#lines] =~ /^mbox\s*\S*?>> $/osm);
    wantarray ? @lines : join("\n", @lines);
}
sub sendZmmailboxRequest($$) {
    my ($host, $cmd, $authTokenRef) = @_;
    my $buf;
    my @lines = sendZmmailboxRequestNP($host, $cmd);

    my @json = ();
    my $json_string;
    my $delegateAuthFound = 0;
    for (@lines) {
        if (defined $authTokenRef) {
            $delegateAuthFound = 1 if ($_ =~ /<DelegateAuthResponse/);
            if ($delegateAuthFound) {
                if ($_ =~ m#<authToken>(.*?)</authToken>#) {
                    $authTokenRef->{'value'} = $1;
                }
            }
        }
        if ($_ =~ /==== SOAP RECEIVE ====/o) {
            @json = ();
        } elsif ($_ =~ /================/o) {
            $json_string = join("", @json);
        } elsif ($_ =~ /zclient.CLIENT_ERROR (.*$)/) {
            die "$1";
        } else {
            push(@json, $_);
        }
    }
    $json_string;
}

