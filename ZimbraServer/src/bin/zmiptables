#!/usr/bin/perl -w
# 
# ***** BEGIN LICENSE BLOCK *****
# Version: ZPL 1.1
# 
# The contents of this file are subject to the Zimbra Public License
# Version 1.1 ("License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.zimbra.com/license
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and limitations
# under the License.
# 
# The Original Code is: Zimbra Collaboration Suite.
# 
# The Initial Developer of the Original Code is Zimbra, Inc.
# Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
# All Rights Reserved.
# 
# Contributor(s):
# 
# ***** END LICENSE BLOCK *****
# 

use strict;
use Getopt::Std;



# Define all port mappings here.
my %MAPPING = (
    80 => 7070,    # HTTP
    443 => 7443,   # HTTS
    143 => 7143,   # IMAP
    993 => 7993,   # IMAP - SSL
    110 => 7110,   # POP
    995 => 7995,   # POP - SSL
);


my $IPTABLES = '/sbin/iptables';

if (-f "/etc/SuSE-release") {
	$IPTABLES = '/usr/sbin/iptables';
}

sub usage() {
print STDERR <<_USAGE_;
Usage: zmiptables -i [<IP address> ...]
       zmiptables -u
       zmiptables -p
       zmiptables -h

Examples

  # Install rules on all IP addresses of host.
  zmiptables -i

  # Install rules on specified IP addresses plus loopback.
  zmiptables -i 192.168.0.10 192.168.0.11

  # Uninstall all rules on all addresses.
  zmiptables -u

  # Print the port mappings to be installed and available IP addresses.
  zmiptables -p

  # Print this usage screen.
  zmiptables -h

To see the rules installed, run:

  iptables -t nat -L

_USAGE_
    exit(1);
}

sub doPort($$$$) {
    my ($op, $ip, $fromPort, $toPort) = @_;

    if ($op ne 'A' && $op ne 'D') {
	die "Invalid iptables operation";
    }
    if ($fromPort == $toPort) {
	die "Can't redirect to same port: port $toPort";
    }
    #print "$op, $ip, $fromPort, $toPort\n";
    my $redir = $op eq 'D' ? '> /dev/null 2>&1' : '';

    my $cmdline;
    $cmdline = "$IPTABLES -t nat -$op OUTPUT -d $ip -p tcp --dport $fromPort -j REDIRECT --to-ports $toPort $redir";
    #print "$cmdline\n";
    system($cmdline);

    if ($ip ne 'localhost' && $ip ne '127.0.0.1') {
	$cmdline = "$IPTABLES -t nat -$op PREROUTING -d $ip -p tcp --dport $fromPort -j REDIRECT --to-ports $toPort $redir";
	#print "$cmdline\n";
	system($cmdline);
    }
}

sub doAllPorts($$) {
    my ($op, $ip) = @_;
    foreach my $fromPort (keys %MAPPING) {
	my $toPort = $MAPPING{$fromPort};
	doPort($op, $ip, $fromPort, $toPort);
    }
}

sub showPorts() {
    print "Port Mappings\n";
    print "-------------\n";
    foreach my $fromPort (keys %MAPPING) {
	my $toPort = $MAPPING{$fromPort};
	printf("%4d --> %4d\n", $fromPort, $toPort);
    }
}

sub clearRules() {
    system("$IPTABLES -t nat -F");
}

sub saveRules() {
    system("/etc/init.d/iptables save > /dev/null 2>&1");
    system("/etc/init.d/iptables restart > /dev/null 2>&1");
}

sub getIPs() {
    my @addrs;
    open(OUT, "/sbin/ip addr |") or die "Unable to get list of IP addresses";
    my $line;
    while (defined($line = <OUT>)) {
	chomp($line);
	# Look for lines like: inet 127.0.0.1/8 ...
	if ($line =~ /^\s+inet\s(\d+\.\d+\.\d+\.\d+)\/\d+\s/) {
	    push(@addrs, $1);
	}
    }
    close(OUT);
    return @addrs;
}

# Sorts list of IP addresses, and makes sure 127.0.0.1 is added at
# the beginning.  Removes duplicates.
sub sanitizeIPList {
    my @list = sort(@_);
    my $last = '';
    my $i;
    for ($i = scalar(@list) - 1; $i >= 0; $i--) {
	my $ip = lc($list[$i]);
	if ($ip eq '127.0.0.1' || $ip eq 'localhost' || $ip eq $last) {
	    splice(@list, $i, 1);  # remove element
	}
	$last = $ip;
    }
    unshift(@list, '127.0.0.1');
    return @list;
}

#
# MAIN
#

my %opts;
getopts("iuph", \%opts) or usage();
if (defined($opts{h})) {
    usage();
}
if (defined($opts{p})) {
    showPorts();
    print "\n";
    print "IP Addresses\n";
    print "------------\n";
    print join("\n", getIPs());
    print "\n";
    exit(0);
}
# Either -i or -u must be specified, but not both.
unless ((defined($opts{i}) && !defined($opts{u})) ||
	(!defined($opts{i}) && defined($opts{u}))) {
    usage();
}

system("/sbin/chkconfig iptables on");

if (defined($opts{i})) {
    # Blow away all existing NAT rules.  (Assume we don't have to coexist with
    # other apps that rely on iptables.)
    clearRules();

    my @addrs;
    if (!defined($ARGV[0])) {
	# Detect all IP addresses.
	@addrs = getIPs();
    } else {
	# IP addresses from command line
	@addrs = @ARGV;
    }
    @addrs = sanitizeIPList(@addrs);

    foreach my $ipAddr (@addrs) {
	doAllPorts('A', $ipAddr);
    }

    saveRules();
} elsif (defined($opts{u})) {
    # Blow away all existing NAT rules.  (Assume we don't have to coexist with
    # other apps that rely on iptables.)
    clearRules();
    saveRules();
}
