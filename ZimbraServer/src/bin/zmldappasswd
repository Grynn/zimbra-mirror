#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# 
# Zimbra Collaboration Suite Server
# Copyright (C) 2005, 2006, 2007 Zimbra, Inc.
# 
# The contents of this file are subject to the Yahoo! Public License
# Version 1.0 ("License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://www.zimbra.com/license.
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
# 
# ***** END LICENSE BLOCK *****
# 
#
# Change password for zimbra_ldap_password, and optionally for
# ldap_root_password.  Updates both the Zimbra local config file and
# ldap configs, and reruns zimbra.ldif
#

use strict;
use Getopt::Std;
use Net::LDAP;
use Net::LDAP::LDIF;
use Net::LDAP::Entry;
use Digest::SHA1;
use MIME::Base64;

our %options = ();
our %loaded = ();
our %saved = ();

my $zimbra_home = getLocalConfig("zimbra_home");
my $zimbra_ldap_userdn = getLocalConfig("zimbra_ldap_userdn");
my $cur_admin_passwd = getLocalConfig("zimbra_ldap_password");

getopts('rlph',\%options) or die "Unable to set options\n";

if ($options{h})  {
   usage();
   exit 1;
}

if ( $options{r} + $options{p} + $options{l} > 1) {
    usage();
    exit 1;
}

if ($#ARGV == -1) {
    usage();
    exit 1;

}

my $password = $ARGV[0];

# Get the SHA password.
my $ctx = Digest::SHA1->new;
$ctx->add("$password");
$ctx->add('salt');
my $ssha_password = '{SSHA}' . encode_base64($ctx->digest . 'salt' ,'');

# Get the LDAP Master
my $ldap_master = getLocalConfig("ldap_master_url");

# MEM 2/9/2006 - ldap_root_password and zimbra_ldap_password have to be in sync
#                until bug 18019 is fixed

print "Updating local config and directory\n";
my $ldap = Net::LDAP->new("$ldap_master")  or  die "$@";

# startTLS Operation, add later
#$mesg = $ldap->start_tls(
#        verify => 'require',
#        capath => "$zimbra_home/conf/ca",
#        ) or die "start_tls: $@";
#
#$mesg->code && die "TLS: " . $mesg->error . "\n";

if ( $options{r}) {
    my  $cur_rootdn_passwd = getLocalConfig("ldap_root_password");
    setLocalConfig("ldap_root_password", "$password");
    my $mesg = $ldap->bind("cn=config", password=>"$cur_rootdn_passwd");
    my $entry = Net::LDAP::Entry->new;
    $entry->changetype ( "modify" );
    $entry->dn('olcDatabase={0}config,cn=config'); 
    $entry->replace(
        olcRootPW=> "$ssha_password",
    );
    $entry->update($ldap);

    # Update slapd.conf
    #
    print "Updating slapd.conf\n";
    my $infile="$zimbra_home/conf/slapd.conf.in";
    my $outfile="/tmp/slapd.conf.$$";
    open(IN,"<$infile");
    open(OUT,">$outfile");
    while (<IN>) {
      if ($_ =~ /^rootpw/) {
        $_ =~ s|^rootpw.*|rootpw $ssha_password|;
        print OUT $_;
      } else {
        print OUT $_;
      }
    }
    rename($outfile, $infile) or system("mv -f", $outfile, $infile);

    # Remove next lines when bug 18019 is fixed
    setLocalConfig("zimbra_ldap_password", "$password");

    $mesg=$ldap->search(base=>"cn=config",filter=>"olcDatabase={3}bdb",attrs=>['olcDatabase']);
    $entry = Net::LDAP::Entry->new;
    $entry->changetype ( "modify" );
    if ($mesg->count()) {
       $entry->dn('olcDatabase={3}bdb,cn=config');
    } else {
       $entry->dn('olcDatabase={2}bdb,cn=config');
    }
    $entry->replace(
        olcRootPW=> "$ssha_password",
    );
    $entry->update($ldap);

    $mesg = $ldap->bind("$zimbra_ldap_userdn", password => "$cur_admin_passwd");
    my $rootdse = $ldap->root_dse();
    if ($rootdse->supported_extension('1.3.6.1.4.1.4203.1.11.1')) {
      require Net::LDAP::Extension::SetPassword;
      $mesg = $ldap->set_password(user => "$zimbra_ldap_userdn",
                                  oldpasswd => "$cur_admin_passwd",
                                  newpasswd => "$password");
    }
    else {
        $mesg = $ldap->modify("$zimbra_ldap_userdn",
                            changes => [
                                delete => [ userPassword => $cur_admin_passwd ],
                                add    => [ userPassword => $password ] ]);
    }
    my $infile = "$zimbra_home/conf/zimbra.ldif";
    my $outfile = "/tmp/zimbra.ldif.$$";
    my $ldifin = Net::LDAP::LDIF->new( "$infile", "r", onerror => 'undef' );
    my $ldifout = Net::LDAP::LDIF->new("$outfile", "w", onerror => 'undef' );
    while( not $ldifin->eof ( ) ) {
      $entry = $ldifin->read_entry ( );
      if ( $ldifin->error ( ) ) {
        print "Error msg: ", $ldifin->error ( ), "\n";
        print "Error lines:\n", $ldifin->error_lines ( ), "\n";
      } else {
          if ($entry->dn() eq "uid=zimbra,cn=admins,cn=zimbra") {
            $entry->replace (
              userPassword => "$ssha_password",
            );
          }
        $ldifout->write($entry);
      }
    }
    $ldifin->done ( ); 
    $ldifout->done ( );
    rename($outfile, $infile) or system("mv -f", $outfile, $infile);
} elsif ( $options{l} ) {
    my $curPass=getLocalConfig("ldap_replication_password");
    setLocalConfig("ldap_replication_password", "$password");
    my $mesg = $ldap->bind("$zimbra_ldap_userdn", password => "$cur_admin_passwd");
    my $rootdse = $ldap->root_dse();
    if ($rootdse->supported_extension('1.3.6.1.4.1.4203.1.11.1')) {
      require Net::LDAP::Extension::SetPassword;
      $mesg = $ldap->set_password(user => 'uid=zmreplica,cn=admins,cn=zimbra',
                                  oldpasswd => "$curPass",
                                  newpasswd => "$password");
    }
    else {
        $mesg = $ldap->modify('uid=zmprelica,cn=admins,cn=zimbra',
                            changes => [
                                delete => [ userPassword => $curPass],
                                add    => [ userPassword => $password ] ]);
    }
    my $infile = "$zimbra_home/conf/zimbra.ldif";
    my $outfile = "/tmp/zimbra.ldif.$$";
    my $ldifin = Net::LDAP::LDIF->new( "$infile", "r", onerror => 'undef' );
    my $ldifout = Net::LDAP::LDIF->new("$outfile", "w", onerror => 'undef' );
    my $entry;
    while( not $ldifin->eof ( ) ) {
      $entry = $ldifin->read_entry ( );
      if ( $ldifin->error ( ) ) {
        print "Error msg: ", $ldifin->error ( ), "\n";
        print "Error lines:\n", $ldifin->error_lines ( ), "\n";
      } else {
          if ($entry->dn() eq "uid=zmreplica,cn=admins,cn=zimbra") {
            $entry->replace (
              userPassword => "$ssha_password",
            );
          }
        $ldifout->write($entry);
      }
    }
    $ldifin->done ( ); 
    $ldifout->done ( );
    rename($outfile, $infile) or system("mv -f", $outfile, $infile);
} elsif ( $options{p} ) {
    my $curPass=getLocalConfig("ldap_postfix_password");
    setLocalConfig("ldap_postfix_password", "$password");
    my $mesg = $ldap->bind("$zimbra_ldap_userdn", password => "$cur_admin_passwd");
    my $rootdse = $ldap->root_dse();
    if ($rootdse->supported_extension('1.3.6.1.4.1.4203.1.11.1')) {
      require Net::LDAP::Extension::SetPassword;
      $mesg = $ldap->set_password(user => 'uid=zmpostfix,cn=admins,cn=zimbra',
                                  oldpasswd => "$curPass",
                                  newpasswd => "$password");
    }
    else {
        $mesg = $ldap->modify('uid=zmpostfix,cn=admins,cn=zimbra',
                            changes => [
                                delete => [ userPassword => $curPass ],
                                add    => [ userPassword => $password ] ]);
    }
    my $infile = "$zimbra_home/conf/zimbra.ldif";
    my $outfile = "/tmp/zimbra.ldif.$$";
    my $ldifin = Net::LDAP::LDIF->new( "$infile", "r", onerror => 'undef' );
    my $ldifout = Net::LDAP::LDIF->new("$outfile", "w", onerror => 'undef' );
    my $entry;
    while( not $ldifin->eof ( ) ) {
      $entry = $ldifin->read_entry ( );
      if ( $ldifin->error ( ) ) {
        print "Error msg: ", $ldifin->error ( ), "\n";
        print "Error lines:\n", $ldifin->error_lines ( ), "\n";
      } else {
          if ($entry->dn() eq "uid=zmpostfix,cn=admins,cn=zimbra") {
            $entry->replace (
              userPassword => "$ssha_password",
            );
          }
        $ldifout->write($entry);
      }
    }
    $ldifin->done ( ); 
    $ldifout->done ( );
    rename($outfile, $infile) or system("mv -f", $outfile, $infile);
} else {
    setLocalConfig("zimbra_ldap_password", "$password");
    my $mesg = $ldap->bind("$zimbra_ldap_userdn", password => "$cur_admin_passwd");
    $mesg->code && die $mesg->error;
    my $rootdse = $ldap->root_dse();
    if ($rootdse->supported_extension('1.3.6.1.4.1.4203.1.11.1')) {
      require Net::LDAP::Extension::SetPassword;
      $mesg = $ldap->set_password(user => "$zimbra_ldap_userdn",
                                  oldpasswd => "$cur_admin_passwd",
                                  newpasswd => "$password");
    }
    else {
        $mesg = $ldap->modify("$zimbra_ldap_userdn",
                            changes => [
                                delete => [ userPassword => $cur_admin_passwd ],
                                add    => [ userPassword => $password ] ]);
    }
    my $cur_rootdn_passwd = getLocalConfig("ldap_root_password");
    $mesg = $ldap->bind("cn=config", password=>"$cur_rootdn_passwd");
    $mesg=$ldap->search(base=>"cn=config",filter=>"olcDatabase={3}bdb",attrs=>['olcDatabase']);
    my $entry = Net::LDAP::Entry->new;
    $entry->changetype ( "modify" );
    if ($mesg->count()) {
       $entry->dn('olcDatabase={3}bdb,cn=config');
    } else {
       $entry->dn('olcDatabase={2}bdb,cn=config');
    }
    $entry->replace(
        olcRootPW=> "$ssha_password",
    );
    $entry->update($ldap);
    my $infile = "$zimbra_home/conf/zimbra.ldif";
    my $outfile = "/tmp/zimbra.ldif.$$";
    my $ldifin = Net::LDAP::LDIF->new( "$infile", "r", onerror => 'undef' );
    my $ldifout = Net::LDAP::LDIF->new("$outfile", "w", onerror => 'undef' );
    while( not $ldifin->eof ( ) ) {
      $entry = $ldifin->read_entry ( );
      if ( $ldifin->error ( ) ) {
        print "Error msg: ", $ldifin->error ( ), "\n";
        print "Error lines:\n", $ldifin->error_lines ( ), "\n";
      } else {
          if ($entry->dn() eq "uid=zimbra,cn=admins,cn=zimbra") {
            $entry->replace (
              userPassword => "$ssha_password",
            );
          }
        $ldifout->write($entry);
      }
    }
    $ldifin->done ( ); 
    $ldifout->done ( );
    rename($outfile, $infile) or system("mv -f", $outfile, $infile);

    # Remove next lines when bug 18019 is fixed
    setLocalConfig("ldap_root_password", "$password");
    my $entry = Net::LDAP::Entry->new;
    $entry->changetype ( "modify" );
    $entry->dn('olcDatabase={0}config,cn=config'); 
    $entry->replace(
        olcRootPW=> "$ssha_password",
    );
    $entry->update($ldap);
    # Update slapd.conf
    #
    print "Updating slapd.conf\n";
    my $infile="$zimbra_home/conf/slapd.conf.in";
    my $outfile="/tmp/slapd.conf.$$";
    open(IN,"<$infile");
    open(OUT,">$outfile");
    while (<IN>) {
      if ($_ =~ /^rootpw/) {
        $_ =~ s|^rootpw.*|rootpw $ssha_password|;
        print OUT $_;
      } else {
        print OUT $_;
      }
    }
    rename($outfile, $infile) or system("mv -f", $outfile, $infile);

}
$ldap->unbind();
$ldap->disconnect();

#
# Usage.
#
sub usage() {

  print "Usage: $0 [-h] [-r] [-p] [-l] newpassword\n";
  print "\t-h: display this help message\n";
  print "\t-r: change ldap_root_passwd\n";
  print "\t-p: change ldap_postfix_password\n";
  print "\t-l: change ldap_replication_password\n";
  print "\tOnly one of r, p, or l may be specified\n";
  print "\tWithout options zimbra_ldap_password is changed\n\n";
  exit 1;

}

sub setLocalConfig {
  my $key = shift;
  my $val = shift;

  if (exists $main::saved{lc}{$key} && $main::saved{lc}{$key} eq $val) {
    return;
  }
  $main::saved{lc}{$key} = $val;
  `/opt/zimbra/bin/zmlocalconfig -f -e ${key}=\'${val}\' 2> /dev/null`;
}

sub getLocalConfig {
  my $key = shift;

  return $main::loaded{lc}{$key}
    if (exists $main::loaded{lc}{$key});

  my $val = `/opt/zimbra/bin/zmlocalconfig -x -s -m nokey ${key} 2> /dev/null`;
  chomp $val;
  $main::loaded{lc}{$key} = $val;
  return $val;
}
