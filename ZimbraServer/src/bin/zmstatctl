#!/usr/bin/perl -w
# 
# ***** BEGIN LICENSE BLOCK *****
# 
# Zimbra Collaboration Suite Server
# Copyright (C) 2007 Zimbra, Inc.
# 
# The contents of this file are subject to the Yahoo! Public License
# Version 1.0 ("License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://www.zimbra.com/license.
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
# 
# ***** END LICENSE BLOCK *****
# 

use strict;
use File::Basename;
use lib "/opt/zimbra/zimbramon/lib";
use Zimbra::Mon::Zmstat;

zmstatInit();

my $isMac = isMac();

sub arrayContains($$) {
    my ($arrayRef, $val) = @_;
    foreach my $elem (@$arrayRef) {
        if ($elem eq $val) {
            return 1;
        }
    }
    return 0;
}

sub getProcList() {
    my @procs;
    my @services;
    my $all = 0;
    my $server = getZimbraServerHostname();
    if ($server) {
        eval { @services = `zmprov -l gs $server | grep -i zimbraServiceEnabled | sed -e 's/^zimbraServiceEnabled: //'`; };
    }
    if (scalar(@services) < 1) {
        print STDERR "Unable to determine ZCS service list on this host.  Assuming all.\n";
        $all = 1;
    }

    if ($all || arrayContains(\@services, 'mailbox')) {
        push(@procs, 'mailbox', 'mysql', 'convertd');
    }
    if ($all || arrayContains(\@services, 'ldap')) {
        push(@procs, 'ldap');
    }
    if ($all || arrayContains(\@services, 'mta')) {
        push(@procs, 'mta');
    }
    if ($all || arrayContains(\@services, 'antispam')) {
        push(@procs, 'amavisd');
    }
    if ($all || arrayContains(\@services, 'antivirus')) {
        push(@procs, 'clam');
    }
    return join(' ', @procs);
}

sub getPidFiles() {
    my @pids;
    my $piddir = getPidFileDir();
    if (-e $piddir) {
        opendir(DIR, $piddir) || die "Unable to opendir $piddir: $!";
        my @pidfiles = readdir(DIR);
        foreach my $file (@pidfiles) {
            if ($file =~ /\.pid$/) {
                push(@pids, "$piddir/$file");
            }
        }
        closedir(DIR);
    }
    return @pids;
}

sub usage() {
    print STDERR <<_USAGE_;
Usage: zmstatctl start|stop|status|rotate
Starts/stops monitoring processes, checks status, or rotates logs.
_USAGE_
    exit(1);
}



#
# main
#

my @TOOL_ALL = (
    'zmstat-proc',
    'zmstat-cpu',
    'zmstat-vm',
    'zmstat-io -x'
);
if (!$isMac) {
    push(@TOOL_ALL, 'zmstat-io');
    push(@TOOL_ALL, 'zmstat-fd');
}
my $TOOL_MYSQL = 'zmstat-mysql';
my $TOOL_MTAQUEUE = 'zmstat-mtaqueue';

my $cmd = $ARGV[0];
if (defined($cmd)) {
    if ($cmd eq 'start') {
        my $procs = getProcList();
        my $doMysql = -x getZimbraHome() . "/mysql/libexec/mysqld" ? 1 : 0;
        my $doMtaQueue = -x getZimbraHome() . "/postfix/sbin/postqueue" ? 1 : 0;
        my $outfile = getZmstatRoot() . "/zmstat.out";
        my $scriptDir = dirname($0);
        my $parentDir = dirname($scriptDir);
        my $toolpath = "$parentDir/libexec";
        foreach my $tool (@TOOL_ALL) {
            my $cmd = "$toolpath/$tool";
            print "Invoking: $cmd\n";
            system("$cmd >> $outfile 2>&1 &");
        }
        if ($doMysql) {
            my $cmd = "$toolpath/$TOOL_MYSQL";
            print "Invoking: $cmd\n";
            system("$cmd >> $outfile 2>&1 &");
        }
        if ($doMtaQueue) {
            my $cmd = "$toolpath/$TOOL_MTAQUEUE";
            print "Invoking: $cmd\n";
            system("$cmd >> $outfile 2>&1 &");
        }
    } elsif ($cmd eq 'stop') {
        my @pids = getPidFiles();
        foreach my $pidFile (@pids) {
            my $pid = readPidFile($pidFile);
            if ($pid) {
                print "Terminating process $pid\n";
                if (!kill(0, $pid)) {
                    unlink($pidFile);
                } elsif (kill(15, $pid) == 1) {  # SIGTERM
                    unlink($pidFile);
                }
            }
        }
        exit(0);  # always return success to calling script
    } elsif ($cmd eq 'status') {
        my @pids = getPidFiles();
        if (scalar(@pids) == 0) {
            # zmstat must not be running if there is no pid file
            exit(1);
        }
        my $numDeadProcs = 0;
        foreach my $pidFile (@pids) {
            my $pid = readPidFile($pidFile);
            if ($pid) {
                if (!kill(0, $pid)) {
                    print STDERR "process $pid in $pidFile not running\n";
                    $numDeadProcs++;
                }
            }
        }
        exit($numDeadProcs > 0 ? 1 : 0);
    } elsif ($cmd eq 'rotate') {
        my @pids = getPidFiles();
        foreach my $pidFile (@pids) {
            my $pid = readPidFile($pidFile);
            if ($pid) {
                print "Sending HUP to process $pid\n";
                my $rc = kill(1, $pid);  # SIGHUP
            }
        }
    } else {
        usage();
    }
} else {
    usage();
}
