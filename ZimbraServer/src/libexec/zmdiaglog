#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# 
# Zimbra Collaboration Suite Server
# Copyright (C) 2005 Zimbra, Inc.
# 
# The contents of this file are subject to the Yahoo! Public License
# Version 1.0 ("License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://www.zimbra.com/license.
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
# 
# ***** END LICENSE BLOCK *****
# 
use strict;
use Getopt::Std;
use POSIX qw(strftime);
use File::Spec;

use vars qw(
    $VERSION $PID_FILE $DEFAULT_DEST $JMAP $JAVA $DEFAULT_TIMEOUT
    $HAVE_GCORE $HAVE_PSTACK $HAVE_LSOF $LOG_FILE $ZMSTAT_CONF
    $ZMDUMPENV $ZMPROV
);

$DEFAULT_DEST = "/tmp/zmdiaglog-$ENV{HOSTNAME}." . $$;
$DEFAULT_TIMEOUT = 120;
$PID_FILE = '/opt/zimbra/log/zmmailboxd_java.pid';
$JMAP = '/opt/zimbra/java/bin/jmap';
$JAVA = '/opt/zimbra/java/bin/java';
$Getopt::Std::STANDARD_HELP_VERSION = 1;
$VERSION = 0.1;
$HAVE_GCORE = has_cmd('gcore');
$HAVE_PSTACK = has_cmd('pstack');
$HAVE_LSOF = has_cmd('lsof');
$LOG_FILE = 'zmdiag.log';
$ZMSTAT_CONF = '/opt/zimbra/conf/zmstat-chart.xml';
$ZMDUMPENV = '/opt/zimbra/bin/zmdumpenv';
$ZMPROV = '/opt/zimbra/bin/zmprov';

my ($login,$pass,$uid,$gid) = getpwnam('zimbra');

if ($< != 0) {
    print STDERR "zmdiaglog needs to be run as root\n";
    exit 1;
}

sub logmsg($) {
    my $msg = shift;
    open(LOGFILE, ">>$LOG_FILE");
    print LOGFILE $msg;
    close(LOGFILE);
    print $msg;
}

sub get_java_version() {
	my $version = "UNKNOWN";
	open(JAVA, "$JAVA -version 2>&1 |") || die "Cannot determine java version: $!";
	my $version_line = <JAVA>;
	if ($version_line =~ /"1\.6/) {
		$version = "1.6";
	} elsif ($version_line =~ /"1\.5/) {
		$version = "1.5";
	} else {
		die "Unknown java version: $version_line";
	}
	close(JAVA);
	$version;
}

sub save_heap_info($$$$) {
	my ($version,$destination,$pid,$timeout) = @_;
	my $histo_cmd;
	my $dump_cmd;
	my $dump_file;
	if ($version eq '1.6') {
		$histo_cmd = "$JMAP -histo:live $pid";
		$dump_cmd  = "su - zimbra -c '$JMAP -dump:live,file=$destination/heapdump.live $pid'";
		$dump_file = "$destination/heapdump.live";
	} elsif ($version eq '1.5') {
		$histo_cmd = "$JMAP -histo $pid";
		$dump_cmd  = "$JMAP -heap:format=b $pid";
		$dump_file = "$destination/heap.bin";
	}
    logmsg "Retrieving JVM heap histogram\n";
    exec_with_timeout("su - zimbra -c '$histo_cmd' > heap.histo 2>&1", $timeout);
    logmsg "Saving JVM heapdump\n";
    my $success = exec_with_timeout("$dump_cmd", $timeout);
    my $dumped = -f "$dump_file";
    if ((!$dumped || !$success) && $version eq '1.6') {
        logmsg "Failed to save heapdump, attempting forced dump\n";
        exec_with_timeout("su - zimbra -c '$JMAP -F -dump:file=$destination/heapdump.snapshot $pid'", $timeout);
        $dumped = -f 'heapdump.snapshot';
    }
    $dumped && $success;
}

sub has_cmd($) {
    my $cmd = shift;
    my $r = system("bash -c 'type -P $cmd' > /dev/null");
    ($r >> 8) == 0;
}

sub get_pid() {
    my $pid = 0;
    if (-f $PID_FILE) {
        eval {
            open(PID_FILE, "<$PID_FILE") || die $!;
            $pid = <PID_FILE>;
            chomp($pid); chomp($pid);
            close PID_FILE;
        };
        if ($@) {
            logmsg "Unable to find pid file, falling back: $@\n";
        }
    }
    if (!$pid) {
        eval {
            open(PS, "ps -ef | grep [j]etty.xml | awk '{ print \$2 }' |")
                    || die $!;
            $pid = <PS>;
            chomp($pid); chomp($pid);
            close(PS);
        };
        if ($@) {
            logmsg "Unable to manually obtain mailboxd pid: $@\n";
        } elsif (!$pid) {
            logmsg "Unable to determine mailboxd pid\n";
        }
    }
    return $pid;
}
sub invoke_thread_dump($$) {
    my ($i, $ts) = @_;
    system("/opt/zimbra/bin/zmthrdump > threaddump.$i.$ts 2>&1");
}

sub collect_thread_stats($) {
    my $pid = shift;
    open(STATS, "cat /proc/$pid/task/*/stat |");
    my @stats = <STATS>;
    close STATS;
    return join("", @stats);
}

sub exec_with_timeout($$) {
    my $cmd = shift;
    my $timeout = shift;
    my $result = 1;

    my $r = fork();
    if ($r) { # parent
        my $reaped = 0;
        local $SIG{'CHLD'} = sub {
            waitpid($r, 0); # reap
            $reaped = 1;
        };
        sleep($timeout);
        if (!$reaped) {
            logmsg "Timeout exceeded executing: '$cmd', killing\n";
            kill('SIGKILL', $r);
            $result = 0;
        }
    } else { # child
        my @cmdary = ('/bin/sh', '-c', $cmd);
        close(STDOUT);
        close(STDERR);
        open(STDOUT, ">>$LOG_FILE");
        open(STDERR, ">>$LOG_FILE");
        exec(@cmdary);
        die "Unable to exec command: $!";
    }
    $result;
}
sub HELP_MESSAGE {
    my $fd = shift;
    print $fd <<"EOF";
Usage: zmdiaglog [-dth]

    -d    - Log destination (Default /tmp/zmdiaglog.PID)
    -t    - Timeout in seconds for hanging commands (Default $DEFAULT_TIMEOUT)
    -h    - This help message
EOF
}


# "main"
my %options;
$options{'d'} = $DEFAULT_DEST;
$options{'t'} = $DEFAULT_TIMEOUT;
getopts('d:t:h', \%options);

if ($options{'h'}) {
    HELP_MESSAGE(\*STDERR);
    exit(0);
}

my $destination = $options{'d'};
$destination    = File::Spec->rel2abs($destination);
my $timeout     = $options{'t'};

if (! -d $destination) {
    qx(mkdir -p $destination); # would use mkdir() but no -p
}
chown $uid, $gid, $destination;
chdir($destination);

my $mailboxd_pid = get_pid();
logmsg "ZCS mailboxd pid: $mailboxd_pid\n";
logmsg "Saving diagnostic logging output to: $destination\n";

my $JAVA_VERSION = get_java_version();
logmsg "Java version: $JAVA_VERSION\n";

logmsg "Saving output of zmdumpenv\n";
exec_with_timeout("su - zimbra -c '$ZMDUMPENV' > zmdumpenv.txt 2>&1", $timeout);
logmsg "Saving server configuration\n";
exec_with_timeout("su - zimbra -c '$ZMPROV gs $ENV{HOSTNAME}' > zmprov-gs.txt 2>&1", $timeout);
exec_with_timeout("su - zimbra -c '$ZMPROV gacf' > zmprov-gacf.txt 2>&1", $timeout);
system("cp /opt/zimbra/conf/localconfig.xml $destination/");

for (my $i = 1; $i <= 10; $i++) {
    logmsg "Collecting thread stats/stacks: $i of 10\n";
    my $TS = strftime("%H-%M-%S", localtime());

    invoke_thread_dump($i, $TS);

    my $stats = collect_thread_stats($mailboxd_pid);
    open(STATS, ">proc-stats.$i.$TS") || warn $i;
    print STATS $stats;
    close(STATS);

    sleep(5);
}
my $dumped = save_heap_info($JAVA_VERSION, $destination, $mailboxd_pid, $timeout);

if ($HAVE_PSTACK) {
    for (my $i = 1; $i <= 3; $i++) {
        logmsg "Collecting process stack: $i of 3\n";
        my $TS = strftime("%H-%M-%S", localtime());
        exec_with_timeout("pstack $mailboxd_pid > pstack.$i.$TS 2>&1", $timeout);
        sleep(5);
    }
} else {
    logmsg "'pstack' is not installed, will not collect process stacks\n";
}

if ($HAVE_GCORE && !$dumped) {
    logmsg "Failed collecting heapdump.  Collecting JVM coredump\n";
    # longer timeout for gcore because it can take a lot longer
    my $got_core = exec_with_timeout("gcore $mailboxd_pid", 300);
    logmsg "Converting coredump to heap snapshot\n";
    if ($got_core) {
        if ($JAVA_VERSION eq "1.6") {
            qx($JMAP -dump:file=heapdump.snapshot $JAVA core.$mailboxd_pid);
        } else {
            qx($JMAP -heap:format=b $JAVA core.$mailboxd_pid);
        }
    }
} elsif (!$HAVE_GCORE) {
    logmsg "'gcore' (gdb) is not installed, will not collect JVM coredump\n";
}

if ($HAVE_LSOF) {
    logmsg "Saving output of LSOF\n";
    qx(lsof > lsof.out 2>&1);
} else {
    logmsg "'lsof' is not installed, will not check fd status\n";
}
mkdir("$destination/logs");
mkdir("$destination/stats");
mkdir("$destination/ld.so.conf");
if (! -f $ZMSTAT_CONF) {
    logmsg "Saving ZCS statistics chart config\n";
    open(CONF, "su - zimbra -c 'zmstat-chart-config' |");
    open(CONF_OUT, ">stats/zmstat-chart.xml");
    while (<CONF>) {
        print CONF_OUT;
    }
    close(CONF);
    close(CONF_OUT);
} else {
    logmsg "Copying ZCS statistics chart config\n";
    system("cp $ZMSTAT_CONF stats/");
}
logmsg "Copying current ZCS logs\n";
system("cp /opt/zimbra/log/my*.log /opt/zimbra/log/mailbox.log /opt/zimbra/log/zmmailboxd.out $destination/logs/");
system("cp /opt/zimbra/db/data/*.err $destination/logs/");
logmsg "Copying today's ZCS statistics\n";
system("cp /opt/zimbra/zmstat/*.csv $destination/stats/");

my $yesterday = time() - (24 * 60 * 60);
my $yesterday_stats_dir = strftime("%Y-%m-%d", localtime($yesterday));
if (-d "/opt/zimbra/zmstat/$yesterday_stats_dir") {
    logmsg "Copying yesterday's ZCS statistics\n";
    mkdir("$destination/stats/$yesterday_stats_dir");
    system("cp /opt/zimbra/zmstat/$yesterday_stats_dir/* $destination/stats/$yesterday_stats_dir/");
}

logmsg "Copying ld.so configuration\n";
system("cp /etc/ld.so.conf /etc/ld.so.conf.d/* $destination/ld.so.conf/");

my $dirname = `pwd`;
chomp($dirname);
chomp($dirname = `basename $dirname`);
logmsg "Zipping up contents into $destination/$dirname.zip\n";
chdir('..');
system("nice -n 19 zip -9r $dirname.zip $dirname/");
rename("$dirname.zip", "$dirname/$dirname.zip");
chdir($destination);
logmsg "\n *** Diagnostics collection done, stored in $destination/$dirname.zip\n";
