#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# 
# Zimbra Collaboration Suite Server
# Copyright (C) 2005, 2006, 2007 Zimbra, Inc.
# 
# The contents of this file are subject to the Yahoo! Public License
# Version 1.0 ("License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
# http://www.zimbra.com/license.
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.
# 
# ***** END LICENSE BLOCK *****
# 

use strict;

my $zimbra_home = "/opt/zimbra";

use lib "${zimbra_home}/zimbramon/lib";
use Zimbra::Util::Common;

use DBI;
use Time::Local;

my $debug = 0;
my $data_source="dbi:mysql:database=zimbra_logger;mysql_read_default_file=${zimbra_home}/conf/my.logger.cnf;mysql_socket=${zimbra_home}/logger/db/mysql.sock";
my $username="zimbra";
my $password = `${zimbra_home}/bin/zmlocalconfig -s -m nokey zimbra_logger_mysql_password`;
chomp $password;
my $platform=`${zimbra_home}/libexec/get_plat_tag.sh`;
chomp $platform;

my $dbh = dbConnect($data_source,$username,$password);

my %MON = (
    'Jan' => '01',
    'Feb' => '02',
    'Mar' => '03',
    'Apr' => '04',
    'May' => '05',
    'Jun' => '06',
    'Jul' => '07',
    'Aug' => '08',
    'Sep' => '09',
    'Oct' => '10',
    'Nov' => '11',
    'Dec' => '12'
  );


my $statement =
  "insert into raw_logs(log_date, loghost, app, pid, msg, postfix_qid) values (?,?,?,?,?,?)";
my $sth = $dbh->prepare($statement);

my $status_statement =
  "insert into service_status(server, service, time, status, loghostname) values (?,?,?,?,?)";
my $s_sth = $dbh->prepare($status_statement);


open FOO, ">/opt/zimbra/log/zmlogger.log" if $debug;
select FOO;
$|=1;
logMsg("INFO", "zmlogger starting up");

my $logregex = qr/(^.{15}) ((\d+\.\d+\.\d+\.\d+) \S+|(\S+)) ([^[]+)\[(\d+)\]: (.*)$/o;

while (<>) {
  next if (/last message repeated/);

  # we should always have a parent process as we are opened with a pipe
  quit(1, "No parent process. logswatch stopped?\n") if (getppid() == 1);

  print FOO "Parent: ", getppid(), "\n" if $debug;
  # attempt to reconnect if mysql dropped
  if (!$dbh->ping) {
    logMsg("DEBUG", "DB Connection dropped.  Attempting to reconnect");
    undef $dbh;
    $dbh = dbConnect($data_source,$username,$password);

    # prepare the statements with the new connection
    $sth = $dbh->prepare($statement);
    $s_sth = $dbh->prepare($status_statement);
  }

  # parse the input
  my ($log_date, $host, $ip, $name, $app, $pid, $msg) = ($_ =~ m/$logregex/);
  $host = (($ip ne "") ? $ip : $name);

  # skip slapd and master 
  unless ($app =~ m/^postfix|amavis|zimbramon/) {
  #if ($app eq 'slapd' || $app eq 'master') {
    logMsg("DEBUG", "Skipping update for app $app");
    next;
  } else {
    logMsg("DEBUG", "hostname:$host app:$app name:$name log_date:$log_date");
  }

  next if ($host eq "");
  my $qid = undef;

  $qid = $1 if ($app =~ /^postfix/ && $msg =~ /^(\S{8,12}): /);

  if ($msg =~ /info: ([^,]+), STATUS: (\S+): (\S+): (Running|Stopped).*$/) {
    my $tm = $1;
    my $hostname = $2;
    my $service = $3;
    my $status = ($4 eq "Running")?1:0;

    # delete previous entries
    my $statement = "delete from service_status ".
      "where server=\'".$hostname."\' and service=\'".$service."\'";
    my $dsth = $dbh->prepare($statement);
    if (!$dsth->execute() ) {
      logMsg("ERROR", $dsth->errstr);
      next;
    }
    # insert new status entries
    if (!$s_sth->execute($hostname, $service, $tm, $status, $host)) {
      logMsg("ERROR", "Status update failed for service:$service host:$host status:$status");
      logMsg("ERROR", $s_sth->errstr);
    } else {
      logMsg("INFO", "Status update for service:$service host:$host status:$status tm:$tm");
    }
    next;
  }

  if (!$sth->execute(logdate_to_sqldate($log_date), $host, $app, $pid, $msg, $qid) ) {
    logMsg("ERROR", "Error inserting $log_date, $host, $app, $pid, $msg");
    logMsg("DEBUG", "From $_");
    logMsg("DEBUG", "DBI errstr: ",$sth->errstr);
    #logMsg("ERROR", "zmlogger insert failed $sth->errstr");
  } else {
    logMsg("INFO", "zmlogger insert completed: $host $app $pid $msg $qid");
  }      

}
quit(1, "Loop failed this should never be reached");

# Sub Routines

sub isSqlRunning {
  `${zimbra_home}/bin/logmysqladmin status > /dev/null 2>&1`;
  return(($? == 0) ? 1 : 0);
}

sub quit($$) {
  my ($rc,$msg) = @_;
  logMsg("INFO", "$msg");
  logMsg("INFO", "zmlogger shutting down");
  close FOO if $debug;
  exit $rc;
}

sub logMsg {
  my ($lvl, $msg) = @_;
  print FOO localtime(time), " $msg\n" if $debug; 
  print "$msg\n" if ($lvl eq "INFO" || $lvl eq "ERROR");
}

sub dbConnect($$$) {
  my ($db_src,$db_user,$db_pass) = @_;
  my $timeout=0;

  while (! isSqlRunning() && ($timeout <= 3600) ) {
    quit(1, "No parent process. logswatch stopped?\n") if (getppid() == 1);
    logMsg("INFO", "database not running.  retrying connection");
    $timeout += sleep 5;

  }
  quit(1, "zmlogger database isn't running") unless isSqlRunning();

  my $dbh = DBI->connect($db_src,$db_user,$db_pass);
  $dbh->{PrintError} = 0 unless $debug;
  $dbh->{RaiseError} = 0 unless $debug;

  if (!$dbh) { 
    logMsg("ERROR", "DB: Can't connect to $db_src: $DBI::errstr");
    quit(1, "Can not connect to database $DBI::errstr");
  }

  return $dbh;
}

sub logdate_to_sqldate {
  my $ts = shift;
  if ($ts eq "" || !defined($ts)) {
    return '';
  }
  # Sep 14 18:30:02

  my @p = split (' ', $ts);
  my @s= localtime();
  my $y = $s[5]+1900;
  my $m = $MON{$p[0]};

  my $dt = sprintf ("%4d-%02d-%02d %s",$y,$m,$p[1],$p[2]);
  return $dt;
}


sub get_last_timestamp {
  my $ts;

  my $statement = "select max(time) from server_stat";

  my $sth = $dbh->prepare($statement);

  if (!$sth->execute) {
    Zimbra::Logger::Log ("err", "DB: $sth->errstr");
    return undef;
  }

  my @ary = $sth->fetchrow_array;

  return (datetime_to_timestamp($ary[0]));
  
}
