#!/usr/bin/perl
use strict;
use lib '/opt/zimbra/zimbramon/lib';
use Sys::Syslog qw(:DEFAULT setlogsock);
use Net::LDAP;

#
# Syslogging options for verbose mode and for fatal errors.
# NOTE: comment out the $syslog_socktype line if syslogging does not
# work on your system.
#
my $syslog_socktype = 'unix';
my $syslog_facility="mail";
my $syslog_options="pid";
our $syslog_priority="info";
our ($verbose, %attr);
my ($option, $action);

setlogsock $syslog_socktype;
openlog $0, $syslog_options, $syslog_facility;

sub smtpd_access_policy {
  my($domain, $ldap, $mesg, $user);
  my $ldap_starttls_supported = getLocalConfig("ldap_starttls_supported");
  my $postfix_pw = getLocalConfig("ldap_postfix_password");
  my $ldap_master = getLocalConfig("ldap_master_url");
  ($user, $domain) = split /\@/, lc $attr{recipient};
  syslog $syslog_priority, "Recipient Domain: %s", $domain if $verbose;
  syslog $syslog_priority, "Recipient userid: %s", $user if $verbose;
  $ldap=Net::LDAP->new("$ldap_master");
  if ( $ldap_starttls_supported ) {
    $mesg = $ldap->start_tls(
          verify => 'require',
          capath => "/opt/zimbra/conf/ca",
          ) or die "start_tls: $@";

    $mesg->code && die "TLS: " . $mesg->error . "\n";
  }
  $mesg = $ldap->bind("uid=zmpostfix,cn=admins,cn=zimbra", password=>$postfix_pw);
  $mesg = $ldap->search(
            base=>"",
            scope=>'sub',
            filter=>"(&(zimbraDomainName=$domain)(objectClass=zimbraDomain))",
            attrs=>['zimbraDomainType','zimbraMailCatchAllForwardingAddress'],
          );
  if ($mesg->count > 0) {
    my $dobject = $mesg->entry(0);
    if (lc($dobject->get_value("zimbraDomainType")) eq "alias") {
      my $robject = $dobject->get_value("zimbraMailCatchAllForwardingAddress");
      syslog $syslog_priority, "Real Domain: %s", $robject if $verbose;
      $mesg = $ldap->search(
                base=>"",
                scope=>'sub',
                filter=>
        "(&(|(zimbraMailDeliveryAddress=$user"."$robject)(zimbraMailAlias=$user"."$robject)(zimbraMailCatchAllAddress=$user"."$robject))(zimbraMailStatus=enabled))",
                attrs=>'1.1',
              );
      $ldap->unbind;
      if ($mesg->count > 0) {
        return "dunno";
      } else { 
        return "defer_if_permit Service temporarily unavailable";
      }
    } else {
      $ldap->unbind;
      return "dunno"; 
    }
  }
  $ldap->unbind;
  return "dunno";
}

#
# Log an error and abort.
#
sub fatal_exit {
    my($first) = shift(@_);
    syslog "err", "fatal: $first", @_;
    exit 1;
}

# Get local config values
sub getLocalConfig {
  my $key = shift;

  return $main::loaded{lc}{$key}
    if (exists $main::loaded{lc}{$key});

  my $val = `/opt/zimbra/bin/zmlocalconfig -x -s -m nokey ${key} 2> /dev/null`;
  chomp $val;
  $main::loaded{lc}{$key} = $val;
  return $val;
}

#
# We don't need getopt() for now.
#
while ($option = shift(@ARGV)) {
    if ($option eq "-v") {
        $verbose = 1;
    } else {
        syslog $syslog_priority, "Invalid option: %s. Usage: %s [-v]",
                $option, $0;
        exit 1;
    }
}

#
# Unbuffer standard output.
#
select((select(STDOUT), $| = 1)[0]);

#
# Receive a bunch of attributes, evaluate the policy, send the result.
#
while (<STDIN>) {
    if (/([^=]+)=(.*)\n/) {
        $attr{substr($1, 0, 512)} = substr($2, 0, 512);
    } elsif ($_ eq "\n") {
        if ($verbose) {
            for (keys %attr) {
                syslog $syslog_priority, "Attribute: %s=%s", $_, $attr{$_};
            }
        }
        fatal_exit "unrecognized request type: '%s'", $attr{"request"}
            unless $attr{"request"} eq "smtpd_access_policy";
        $action = smtpd_access_policy();
        syslog $syslog_priority, "Action: %s", $action if $verbose;
        print STDOUT "action=$action\n\n";
        %attr = ();
    } else {
        chop;
        syslog $syslog_priority, "warning: ignoring garbage: %.100s", $_;
    }
}
