#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# Version: MPL 1.1
# 
# The contents of this file are subject to the Mozilla Public License
# Version 1.1 ("License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.zimbra.com/license
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and limitations
# under the License.
# 
# The Original Code is: Zimbra Collaboration Suite Server.
# 
# The Initial Developer of the Original Code is Zimbra, Inc.
# Portions created by Zimbra are Copyright (C) 2006 Zimbra, Inc.
# All Rights Reserved.
# 
# Contributor(s):
# 
# ***** END LICENSE BLOCK *****
# 

#use strict;

use strict;

use lib "/opt/zimbra/zimbramon/lib/zimbrapm";
use lib "/opt/zimbra/zimbramon/lib/zimbrapm/SOAP";
use lib "/opt/zimbra/zimbramon/lib";

use Getopt::Std;
my %options = ();

unless ( getopts( 'a:', \%options ) ) { usage(); }

my $account_id = $options{a};

use POSIX ":sys_wait_h";
use LWP::UserAgent;

use Zimbra::SOAP::XmlElement;
use Zimbra::SOAP::XmlDoc;
use Zimbra::SOAP::Soap;

use Time::Local;

# Exit if software-only node.
exit(0) unless (-f '/opt/zimbra/conf/localconfig.xml');

my $ACCTNS = "urn:zimbraAccount";
my $MAILNS = "urn:zimbraMail";
my $ADMINNS = "urn:zimbraAdmin";
my $SOAP = $Zimbra::SOAP::Soap::Soap12;

my $authToken;
my $START;
my $END;
my $PERIOD;

#our %GlobalOpts;

sub usage { exit 1; }

sub get_auth_token {
	my $host = shift;
	my $user = shift;
	my $pass = shift;

	# print "Authenticating to $host as $user/$pass\n";

	my $url = "https://$host:7071/service/admin/soap/";

	my $d = new Zimbra::SOAP::XmlDoc;
	$d->start('AuthRequest', $ADMINNS);
	$d->add('name', undef, { by => "name"}, "$user");
	$d->add('password', undef, undef, "$pass");
	$d->end();

	my $authResponse;
	eval {
		$authResponse = $SOAP->invoke($url, $d->root());
	};

	if (!$authResponse) {return undef;}
	my $authToken = $authResponse->find_child('authToken')->content;

	# print "authToken($authToken)\n";

	return $authToken;

}

sub purgeMessages {
	my $zimbraId = shift;
	my $host = "localhost";
	my $user = "zimbra";
	chomp $user;
	my $pass = `zmlocalconfig -s -m nokey zimbra_ldap_password`;
	chomp $pass;
	$authToken = get_auth_token ($host, $user, $pass );

	if (!defined ($authToken)) {exit 1;}

	my $context = $SOAP->zimbraContext($authToken, "");

	my $url = "https://$host:7071/service/admin/soap/";

	my $d = new Zimbra::SOAP::XmlDoc;
	$d->start('PurgeMessagesRequest', $ADMINNS);
	if ($zimbraId) {
		$d->add('mbox', undef, {id => $zimbraId}, undef);
		}
	$d->end();

	my $response = $SOAP->invoke($url, $d->root(), $context);

	# print $response->to_string("pretty"),"\n";

	if ($response->{name} ne "PurgeMessagesResponse") {
		print STDERR "Error: ".$response->to_string("pretty")."\n";
		return undef;
	}

}
purgeMessages($account_id);
